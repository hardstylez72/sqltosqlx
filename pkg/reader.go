package pkg

import (
	"bytes"
	"regexp"
	"strings"
	"text/template"
)

const (
	outTemplate = `
type {{.Name}} struct { {{range .Lines}}
    {{.Name}} {{.Type}} {{.Tag}} {{end}}
}`
)

type ConvertedStruct struct {
	Name string
	Lines []Line
}

type Line struct {
	Name string
	Type string
	Tag string
}

func Convert(data string) (string, error) {
	convertedLines := make([]Line, 0)

	data = strings.ReplaceAll(data, "\n", "")
	lines := strings.Split(data, ",")
	for _, line := range lines {
		convertedLines = append(convertedLines, convertSQLLine(line))
	}

	out := &ConvertedStruct{
		Name:  "autoGenerated",
		Lines: convertedLines,
	}

	return makeStruct(out)
}

func makeStruct(in *ConvertedStruct) (string,error) {
	t, err := template.New("convertedStruct").Parse(outTemplate)
	if err != nil {
		return "", err
	}

	var outString []byte
	wr := bytes.NewBuffer(outString)
	err = t.Execute(wr, in)
	if err != nil {
		return "", err
	}
	return wr.String(), nil
}


func removeMultipleSpaces(line string) string {
	space := regexp.MustCompile(`\s+`)
	return space.ReplaceAllString(line, " ")
}

func convertSQLLine(line string) Line {

	line = removeMultipleSpaces(line)

	sqlName, sqlType := getSQLNameAndType(line)

	return Line{
		Name: convertName(sqlName),
		Type: convertType(sqlType, line),
		Tag:  "`db:\"" + sqlName + "\"`",
	}
}

func convertType(sqlType,fullLine string) string {
	isNullable := isNullable(fullLine)

	switch true {
	case isStringType(sqlType):
		if isNullable {
			return "sql.NullString"
		}
		return "string"
	case isTimeType(sqlType):
		if isNullable {
			return "sql.NullTime"
		}
		return "time.Time"
	case isBoolType(sqlType):
		if isNullable {
			return "sql.NullBool"
		}
		return "bool"
	}
	return ""
}


func isTimeType(sqlType string) bool {
	rgs := []*regexp.Regexp{
		regexp.MustCompile("timestamp"),
	}

	for _, rg := range rgs {
		if rg.MatchString(sqlType) {
			return true
		}
	}
	return false
}
func isStringType(sqlType string) bool {
	rgs := []*regexp.Regexp{
		regexp.MustCompile("uuid"),
		regexp.MustCompile(`varchar\(\d+\)`),
	}

	for _, rg := range rgs {
		if rg.MatchString(sqlType) {
			return true
		}
	}
	return false
}

func isBoolType(sqlType string) bool {
	rgs := []*regexp.Regexp{
		regexp.MustCompile("bool"),
		regexp.MustCompile(`boolean`),
	}

	for _, rg := range rgs {
		if rg.MatchString(sqlType) {
			return true
		}
	}
	return false
}

func getSQLNameAndType(line string) (string, string) {
	var varName, varType string
	rg := regexp.MustCompile(`^[a-z]`)
	words := strings.Split(line, " ")
	for index, word := range words {
		if rg.MatchString(word) {
			varName = word
			varType = words[index+1]
			break
		}
	}
	return varName, varType
}

func convertName(line string) string {
	line = strings.ToLower(line)
	line = strings.TrimSpace(line)

	return underscoreToCamelCase(line)
}

func underscoreToCamelCase(s string) string {
	return strings.Replace(strings.Title(strings.Replace(strings.ToLower(s), "_", " ", -1)), " ", "", -1)
}

func isNullable(line string) bool {
	line = strings.ToLower(line)
	matched, err := regexp.MatchString(`not\s+null|primary\s+key`, line)
	if err != nil {
		panic(err)
	}
	return !matched
}

